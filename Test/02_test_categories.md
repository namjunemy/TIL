## 3. 테스트의 필요성과 테스트 3분류

### 1. 테스트는 왜 필요한가

- 내게 레거시 코드란, 단순히 테스트 루틴이 없는 코드다. 다만 이 정의는 다소 불완전 하다. - 마이클 페더스 -
- 잘 돌아가던 코드가 이번 배포로 인해서 동작하지 않는 상황(Regression)을 한 두번 경험하다 보면, 수정과 배포가 무서워진다.
    - 큰 문제일까?
        - 큰 문제이다. 엔지니어들의 심리 영역 문제를 넘어서 서비스 품질과도 연관이 된다.
        - 시스템적으로 해결이 되어야 한다.
        - 이 때 조직은 테스트를 필요로 한다.
- 테스트는 좋은 아키텍처를 유도하기 때문에 필요하다.
    - 나쁜 아키텍처와 테스트가 없는 프로젝트는 시간이 지날수록 유지보수에 대한 비용이 증가한다.
- 좋은 아키텍처란 무엇일까?
    - 꼭 빠지지 않고 나오는 개념이 있다.
    - SOLID
    - SOLID와 테스트간에는 상호 보완 관계가 존재 한다.
    
    ![image.png](./Test/test_01.png)
    
    - SOLID원칙을 잘 지켜 경계가 만들어지면, 이로 인해서 회귀 버그가 생기는 것을 막을 수 있다.
    - 우리는 둘의 교집합을 지켜야 한다.
    - 좋은 설계와 회귀 버그 방지 모두를 놓쳐선 안된다.
    - SOLID에 대해서 자세히 알아보자
        - SRP(Single Responsibility Principle), 단일 책임 원칙
            - 하나의 클래스는 하나의 책임만을 가져야 한다.
            - 테스트를 명료하게 작성하려고 노력하면 자연스럽게 지켜진다.
            - 테스트가 너무 많아져서 이게 무슨 목적의 클래스인지 눈에 안들어오는 시점이 생긴다.
            - **이 때가 클래스를 분할해야 하는 시점이다.**(테스트가 보내는 신호다)
            - 그러면서 책임이 자연스럽게 분배 된다.
        - OCP(Open Close Principle), 개방 폐쇄 원칙
            - 확정에는 열려있어야 하고, 수정에는 닫혀 있어야 한다는 원칙.
            - 테스트를 작성하다 보면, 이 원칙을 지키게끔 토드를 작성할수 밖에 없게 된다.
            - 테스트를 작성하려면 테스트 컴포넌트와 프로덕션 컴포넌트를 나눠서 작업하게 되고, 필요에 따라서 이 컴포넌트를 자유자재로 탈부탁이 가능하게 개발하게 된다.
        - LSP(Liskov Substitution Principle), 리스코프 치환 원칙
            - 슈퍼 클래스의 계약을 서브 클래스가 제대로 치환하는지 확인하라는 원칙
            - 이상적으로 테스트는 모든 케이스에 대해서 커버하고 있어야 하니까
            - 치환 여부를 테스트가 알아서 판단 해 줄 것이다.
        - ISP(Interface Segregation Principle), 인터페이스 분리 원칙
            - 테스트는 그 자체로 인터페이스를 직접 사용해 볼 수 있는 환경이다.
            - 그래서 테스트를 작성하다 보면 종종 불필요한 의존성이 보이곤 한다.
            - “인터페이스가 많아서 뭘 호출해야할지 모르겠는데?”
            - 결국 단일 책임 원칙과 맥을 같이 한다.
            - 저 생각이 났을 때, **인터페이스를 분리해 줘야 하는 시점 인 것이다.**
            - 결과적으로 개발자는 리팩토링 하게 된다.
        - DIP(Dependency Inversion Principle) 의존성 역전 원칙
            - 테스트 할 때 Fake나 Dummy를 많이 사용한다.
            - 이걸 자연스럽게 하기 위해선 의존성 역전이 되어있어야 하는 경우가 많다.
            - 그러다보니 이 원칙도 지켜지게 된다.
    - 오해 하면 안된다. 테스트를 작성하면 SOLID 원칙이 지켜지는 것은 아니다.
    - 테스트를 작성하면서 이런것도 챙겨야 한다는 의미이고,
    - 테스트를 작성하다보면 결국 SOLID가 따라 온다
    - 테스트를 회귀 버그 방지와 설계를 위한 도구로 바라보면 테스트의 가치가 더 높아 진다.
    
    ![image.png](./Test/test_02.png)
    

### 2. 테스트 3분류

- 전통적인 테스트 3분류
    
    ![image.png](./Test/test_03.png)
    
    - 각각이 의미하는 것을 명확히 알 수 있나?
    - 통합은 뭘 통합한다는걸까?
    - API 여러개 찌르는건 통합 테스트일까? 맞다면 통합은 왜 API 테스트 아래에 있을까
    - 구체적은 아니지만 대충 이해는 되니까 넘어간다.
    - 근데 공부하면 할수록 정의는 사람마다 다르다. 헷갈리기만 한다.
- 구글 테스트 3분류
    
    ![image.png](./Test/test_04.png)
    
    - 소형 테스트
        - 단일 서버/단일 프로세스/단일 스레드에서 돌아가는 테스트
        - 디스크 I/O 사용 안됨
        - Blocking call 허용 안됨
        - Thread.sleep()이 있으면 소형 테스트가 아니다!
        - 소형 테스트는 매우매우 중요하다.
        - 위의 특성들 때문에 결과가 결정적이고, 속도가 빠르다.
    - 중형 테스트
        - 단일 서버 / 멀티 프로세스 / 멀티 스레드로 수행 조건이 완화된다.
        - 이는 H2같은 테스트용 DB를 사용할 수 있게 된다는 의미이다.
        - 이 말은 H2를 사용한 테스트는 소형 테스트가 아니다!
        - 중형 테스트는 소형 테스트 보다 느리고, 멀티스레드 환경에서 어떻게 동작할지 모르기 때문에 결과가 항상 같다는 보장을 하지 못한다.
        - 테스트 결과가 외부 모듈에 따라서 달라지기 때문에.
        - 중형 테스트를 너무 많이 만드는 실수는 Spring 개발자들이 정말 많이 저지르는 실수이기도 하다.
        - 모든 테스트가 H2를 사용하고 있고, 그래서 거의 모든 테스트는 중형이다.
        - 피라미드를 통해 알 수 있듯이 소형 테스트가 전체 테스트의 80%는 차지해야 좋은 방향성이다.
    - 대형 테스트
        - 멀티서버도 허용 한다.
        - 보통 End to end 테스트를 의미 한다.
    - 우리가 집중해야 하는건 소형 테스트이다. 빠르고 결정적인.
        - 이 테스트를 여러개 만드는 방향으로 진행해서 코드 커버리지를 높여야 한다.
